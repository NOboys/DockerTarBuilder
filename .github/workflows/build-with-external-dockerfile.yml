name: Universal Docker Build with Multi-stage Support

on:
  workflow_dispatch:
    inputs:
      dockerfile_url:
        description: 'Dockerfile的Raw URL'
        required: true
        type: string
      image_name:
        description: '构建的镜像名称'
        required: false
        default: 'built-image'
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download and Analyze Dockerfile
        id: dockerfile_analysis
        run: |
          echo "下载Dockerfile..."
          curl -sSLf -o Dockerfile.external "${{ github.event.inputs.dockerfile_url }}"
          
          # 分析Dockerfile中的所有ARG声明
          echo "=== Dockerfile分析结果 ==="
          echo "1. 所有ARG声明:"
          grep -n "^ARG" Dockerfile.external
          
          echo "2. 所有没有默认值的ARG:"
          grep "^ARG" Dockerfile.external | grep -v "=" | awk '{print $2}' | sort -u
          
          echo "3. 各阶段的ARG使用情况:"
          current_stage="initial"
          stage_num=0
          while IFS= read -r line; do
            if [[ "$line" =~ ^FROM.*AS.* ]]; then
              current_stage=$(echo "$line" | grep -o "AS [^ ]*" | cut -d' ' -f2)
              stage_num=$((stage_num+1))
              echo "阶段 $stage_num: $current_stage"
            elif [[ "$line" =~ ^ARG.* ]]; then
              echo "  - $line"
            fi
          done < Dockerfile.external
          
          # 提取所有需要的构建参数
          REQUIRED_ARGS=$(grep "^ARG" Dockerfile.external | grep -v "=" | awk '{print $2}' | sort -u)
          echo "4. 需要在构建时提供的参数:"
          echo "$REQUIRED_ARGS"
          
          # 保存分析结果
          if [ -n "$REQUIRED_ARGS" ]; then
            echo "required_args=$REQUIRED_ARGS" >> $GITHUB_OUTPUT
            echo "dockerfile_path=Dockerfile.external" >> $GITHUB_OUTPUT
          fi

      - name: Setup Build Environment
        run: |
          echo "=== 构建环境设置 ==="
          echo "请确保在构建时提供以下参数:"
          echo "${{ steps.dockerfile_analysis.outputs.required_args }}"
          
          # 创建构建参数文件模板
          cat > build-args-template.txt << EOF
          # 请将以下参数替换为实际值
          # 每行格式: ARG_NAME=value
          
          EOF
          
          # 添加参数说明
          while IFS= read -r arg; do
            case $arg in
              ENABLE_PROXY)
                echo "ENABLE_PROXY=false  # 是否启用代理加速" >> build-args-template.txt
                ;;
              ETCD_VERSION)
                echo "ETCD_VERSION=v3.4.14  # etcd版本" >> build-args-template.txt
                ;;
              APISIX_VERSION)
                echo "APISIX_VERSION=master  # APISIX版本" >> build-args-template.txt
                ;;
              APISIX_DASHBOARD_VERSION)
                echo "APISIX_DASHBOARD_VERSION=master  # 仪表板版本" >> build-args-template.txt
                ;;
              APISIX_DASHBOARD_TAG)
                echo "APISIX_DASHBOARD_TAG=master  # 仪表板标签（与版本相同）" >> build-args-template.txt
                ;;
              *)
                echo "$arg=value  # 请提供值" >> build-args-template.txt
                ;;
            esac
          done <<< "${{ steps.dockerfile_analysis.outputs.required_args }}"
          
          echo "构建参数模板已生成，请查看 build-args-template.txt"

      - name: Input Build Arguments
        id: input_args
        run: |
          echo "=== 构建参数输入 ==="
          
          # 从环境变量或文件读取构建参数
          # 这里使用硬编码的示例值，实际使用时应该从GitHub Secrets或输入获取
          cat > .build-args.env << 'EOF'
          ENABLE_PROXY=false
          ETCD_VERSION=v3.4.14
          APISIX_VERSION=master
          APISIX_DASHBOARD_VERSION=master
          APISIX_DASHBOARD_TAG=master
          EOF
          
          echo "使用的构建参数:"
          cat .build-args.env
          
          # 转换为docker/build-push-action需要的格式
          BUILD_ARGS_YAML=""
          while IFS='=' read -r key value; do
            # 跳过注释和空行
            [[ $key =~ ^#.* ]] && continue
            [[ -z $key ]] && continue
            BUILD_ARGS_YAML+="$key=$value"$'\n'
          done < .build-args.env
          
          echo "build_args_yaml<<EOF" >> $GITHUB_ENV
          echo "$BUILD_ARGS_YAML" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 关键修复：确保所有构建参数传递到所有阶段
      - name: Build Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ steps.dockerfile_analysis.outputs.dockerfile_path }}
          push: false
          tags: ${{ github.event.inputs.image_name }}:latest
          outputs: type=docker,dest=/tmp/image-${{ github.run_id }}.tar
          # 关键：这里传递所有构建参数
          build-args: |
            ${{ env.build_args_yaml }}
          # 启用详细日志以便调试
          provenance: false
          no-cache: false

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ github.run_id }}
          path: /tmp/image-${{ github.run_id }}.tar
          retention-days: 0.25

      - name: Cleanup
        if: always()
        run: |
          rm -f Dockerfile.external .build-args.env build-args-template.txt /tmp/image-${{ github.run_id }}.tar
          docker image prune -f
